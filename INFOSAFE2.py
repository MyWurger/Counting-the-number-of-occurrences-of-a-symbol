# Импортируем необходимые библиотеки
import pandas as pd  # Для работы с данными и создания Excel файлов
import os  # Для работы с путями файлов
import sys  # Для работы с аргументами командной строки и выхода из программы
import chardet  # Для определения кодировки файла


def process_file(file_path):
    """
    Анализирует файл, подсчитывая частоту каждого символа и автоматически определяя кодировку.
    
    Эта функция выполняет следующие шаги:
    1. Открывает файл в бинарном режиме и считывает его содержимое.
    2. Определяет кодировку файла с помощью библиотеки chardet.
    3. Декодирует содержимое файла, используя обнаруженную кодировку или Windows-1251.
    4. Подсчитывает частоту каждого символа в тексте.
    5. Вычисляет вероятность появления каждого символа.
    6. Выводит информацию о символах, их количестве и вероятности.
    7. Возвращает общее количество символов и словарь с частотами.

    Args:
        file_path (str): Путь к анализируемому файлу.

    Returns:
        tuple: (общее количество символов, словарь частот символов)

    Raises:
        FileNotFoundError: Если указанный файл не найден.
        Exception: При любых других ошибках обработки файла.
    """
    try:
        # Открываем файл в бинарном режиме для корректной работы с разными кодировками
        with open(file_path, 'rb') as file:
            # Читаем все содержимое файла в переменную
            file_content = file.read()

        # Определяем кодировку файла с помощью библиотеки chardet
        detection_result = chardet.detect(file_content)
        # Извлекаем определенную кодировку из результата
        encoding = detection_result['encoding']
        # Выводим обнаруженную кодировку на экран
        print(f"Обнаружена кодировка: {encoding}")

        # Проверяем, является ли обнаруженная кодировка Windows-1251
        if encoding.lower() != 'windows-1251':
            try:
                # Пытаемся декодировать текст с обнаруженной кодировкой
                text = file_content.decode(encoding)
            except UnicodeDecodeError:
                # Если декодирование не удалось, выводим сообщение об ошибке
                print(f"Ошибка декодирования с кодировкой {encoding}, пробуем Windows-1251.")
                # Пытаемся декодировать с использованием Windows-1251
                text = file_content.decode('windows-1251')
        else:
            # Если кодировка Windows-1251, используем её для декодирования
            text = file_content.decode(encoding)

        # Инициализируем словарь для подсчета частоты символов
        char_frequency = {}
        # Проходим по каждому символу в тексте
        for char in text:
            # Увеличиваем счетчик для текущего символа или устанавливаем 1, если символ встречается впервые
            char_frequency[char] = char_frequency.get(char, 0) + 1

        # Вычисляем общее количество символов в тексте
        total_chars = len(text)

        # Выводим заголовок для информации о вероятностях
        print("\nВероятности появления символов:")
        # Проходим по каждому символу и его количеству в словаре частот
        for char, count in char_frequency.items():
            # Вычисляем вероятность появления символа
            probability = count / total_chars
            # Выводим информацию о символе, его количестве и вероятности
            print(f"Символ: '{char}', Количество: {count}, Вероятность: {probability}")

        # Возвращаем общее количество символов и словарь с частотами
        return total_chars, char_frequency

    except FileNotFoundError:
        # Если файл не найден, выводим сообщение об ошибке
        print(f"Ошибка: Файл {file_path} не найден.")
        # Завершаем программу с кодом ошибки 1
        sys.exit(1)
    except Exception as e:
        # Если произошла любая другая ошибка, выводим её описание
        print(f"Ошибка при обработке файла {file_path}: {e}")
        # Завершаем программу с кодом ошибки 1
        sys.exit(1)



def write_to_excel(file_name, total_char_count, char_frequency):
    """
    Записывает результаты анализа в Excel файл.
    
    Эта функция выполняет следующие шаги:
    1. Создает список словарей с данными о каждом символе.
    2. Вычисляет дополнительную информацию для каждого символа (ASCII код, шестнадцатеричное и двоичное представление).
    3. Сортирует данные по номеру символа.
    4. Создает DataFrame из полученных данных.
    5. Добавляет итоговые строки с общим количеством символов и общей вероятностью.
    6. Записывает полученный DataFrame в Excel файл.

    Args:
        file_name (str): Имя файла для сохранения результатов (без расширения).
        total_char_count (int): Общее количество символов в исходном файле.
        char_frequency (dict): Словарь с частотами символов.

    Raises:
        Exception: При ошибках записи в Excel файл.
    """
    # Инициализируем список для хранения данных каждой строки
    rows = []
    # Инициализируем переменную для подсчета общей вероятности
    total_probability = 0
    
    # Проходим по каждому символу и его количеству в словаре частот
    for char, count in char_frequency.items():
        try:
            # Кодируем символ в Windows-1251 для получения байтового представления
            byte_representation = char.encode('windows-1251')
            # Получаем ASCII код первого байта
            ascii_code = byte_representation[0]
            # Вычисляем новый номер, увеличивая ASCII код на 1
            new_number = ascii_code + 1
            # Вычисляем вероятность появления символа
            probability = count / total_char_count
            # Добавляем вероятность к общей сумме
            total_probability += probability

            # Добавляем новую строку данных в список
            rows.append({
                "Номер": new_number,
                "Номер ASCII": ascii_code,
                "Шестнадцатеричный": f"0x{ascii_code:02X}",  # Шестнадцатеричное представление
                "Двоичный": f"{ascii_code:08b}",  # Двоичное представление
                "Символ": char,
                "Количество": count,
                "Вероятность": probability
            })
        except Exception as e:
            # Если произошла ошибка при обработке символа, выводим сообщение
            print(f"Ошибка при обработке символа '{char}': {e}")

    # Сортируем строки по номеру
    rows.sort(key=lambda x: x["Номер"])

    # Создаем DataFrame из списка строк
    df = pd.DataFrame(rows)

    # Создаем DataFrame с итоговыми строками
    total_rows = pd.DataFrame([
        {"Номер": "Общее количество символов", "Количество": total_char_count},
        {"Номер": "Общая вероятность", "Вероятность": total_probability}
    ])
    # Объединяем основной DataFrame с итоговыми строками
    df = pd.concat([df, total_rows], ignore_index=True)

    try:
        # Создаем Excel файл и записываем в него данные
        with pd.ExcelWriter(f"{file_name}.xlsx", engine="xlsxwriter") as writer:
            df.to_excel(writer, sheet_name="Частоты", index=False)
        # Выводим сообщение об успешной записи
        print(f"Результаты успешно записаны в {file_name}.xlsx")
    except Exception as e:
        # Если произошла ошибка при записи в Excel, выводим сообщение
        print(f"Ошибка при записи в Excel: {e}")
        # Завершаем программу с кодом ошибки 1
        sys.exit(1)



def main():
    """
    Основная функция программы.
    
    Эта функция выполняет следующие шаги:
    1. Проверяет правильность аргументов командной строки.
    2. Формирует путь к файлу для анализа.
    3. Вызывает функцию анализа файла.
    4. Записывает результаты в Excel файл.

    Raises:
        Exception: При любых непредвиденных ошибках в процессе выполнения.
    """
    try:
        # Проверяем, что передан один аргумент командной строки
        if len(sys.argv) == 2:
            # Получаем имя файла без расширения из аргумента
            file_name_without_extension = sys.argv[1]
            # Задаем имя папки, где хранятся файлы
            files_folder = "src"
            # Задаем список допустимых расширений
            extensions = ["txt"]
            # Формируем полный путь к файлу
            file_path = os.path.join(files_folder, f"{file_name_without_extension}.{extensions[0]}")
        else:
            # Если аргументов неверное количество, выводим инструкцию по использованию
            print(f"Использование: {sys.argv[0]} <имя файла без расширения>")
            # Завершаем программу с кодом ошибки 1
            sys.exit(1)

        # Вызываем функцию обработки файла
        total_char_count, char_frequency = process_file(file_path)
        # Получаем имя файла без расширения и пути
        file_name = os.path.splitext(os.path.basename(file_path))[0]
        # Записываем результаты в Excel файл
        write_to_excel(file_name, total_char_count, char_frequency)

    except Exception as e:
        # Если произошла любая непредвиденная ошибка, выводим её описание
        print(f"Ошибка: {e}")
        # Завершаем программу с кодом ошибки 1
        sys.exit(1)

# Проверяем, что скрипт запущен напрямую, а не импортирован
if __name__ == "__main__":
    # Вызываем основную функцию программы
    main()